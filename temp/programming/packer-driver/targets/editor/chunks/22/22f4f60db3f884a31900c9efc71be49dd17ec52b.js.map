{"version":3,"sources":["file:///D:/cocos%20creator%20project/TeamBattle/assets/resources/scripts/characters/components/SkillComponent.ts"],"names":["_decorator","Component","log","warn","ccclass","property","SkillComponent","_skills","Map","start","update","deltaTime","info","values","isReady","cooldownTimer","isSkillReady","skillId","get","tryUseSkill","node","name","scheduleOnce","executeSkillEffectPlaceholder"],"mappings":"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","sourcesContent":["import { _decorator, Component, log, warn } from 'cc';\n// import { SkillBase } from '../skills/SkillBase'; // 基础技能类或接口\n// import { CharacterStats } from './CharacterStats'; // 可能需要获取施法速度、冷却缩减等\n// import { TargetingComponent } from './TargetingComponent'; // 获取当前目标以供技能使用\n\nconst { ccclass, property } = _decorator;\n\n// 内部用于追踪技能状态的数据结构\ninterface SkillRuntimeInfo {\n    // skill: SkillBase;\n    cooldownTimer: number;\n    isReady: boolean;\n}\n\n/**\n * 管理角色拥有的技能列表、冷却时间和使用请求。\n * AIComponent 会查询此组件以决定是否使用技能，并请求使用。\n */\n@ccclass('SkillComponent')\nexport class SkillComponent extends Component {\n\n    // @property([SkillAsset]) // TODO: 如何在编辑器中配置技能列表? (可能需要自定义资源类型 SkillAsset)\n    // skillAssets: SkillAsset[] = [];\n\n    // @property(CharacterStats)\n    // private stats: CharacterStats = null;\n\n    // @property(TargetingComponent)\n    // private targeting: TargetingComponent = null;\n\n    // --- 内部状态 ---\n    private _skills: Map<string, SkillRuntimeInfo> = new Map(); // 使用技能 ID 作为 key\n\n    start() {\n        // TODO: 从 skillAssets 初始化 _skills Map\n        // for (const asset of this.skillAssets) {\n        //     const skill = createSkillInstance(asset); // 需要一个工厂方法\n        //     if (skill) {\n        //         this._skills.set(skill.id, {\n        //             skill: skill,\n        //             cooldownTimer: 0,\n        //             isReady: true\n        //         });\n        //     }\n        // }\n        warn(\"SkillComponent initialization from assets not implemented!\");\n    }\n\n    update(deltaTime: number) {\n        // 更新所有技能的冷却时间\n        for (const info of this._skills.values()) {\n            if (!info.isReady) {\n                // TODO: 应用冷却缩减 (stats.cooldownReduction)\n                info.cooldownTimer -= deltaTime;\n                if (info.cooldownTimer <= 0) {\n                    info.isReady = true;\n                    // log(`[${this.node.name}] Skill [${info.skill.id}] is ready.`); // 暂时注释，因为 SkillBase 未定义\n                    // 发出技能就绪事件?\n                    // this.node.emit('skill-ready', info.skill.id);\n                }\n            }\n        }\n    }\n\n    // --- 由 AIComponent 调用 --- (或由玩家输入调用)\n\n    /**\n     * 查询指定 ID 的技能是否已准备好可以使用 (冷却完毕且满足基本条件)。\n     * @param skillId 技能的唯一 ID\n     */\n    public isSkillReady(skillId: string): boolean {\n        const info = this._skills.get(skillId);\n        if (!info) return false;\n        // TODO: 后续可以检查资源 (MP), 施法状态等\n        return info.isReady;\n    }\n\n    /**\n     * 尝试使用指定 ID 的技能。\n     * AI 会调用这个方法，内部会进行最终的条件检查 (目标、距离、资源等)。\n     * @param skillId 要尝试使用的技能 ID\n     * @returns 如果成功开始施法或立即生效，则返回 true；否则返回 false。\n     */\n    public tryUseSkill(skillId: string): boolean {\n        const info = this._skills.get(skillId);\n        if (!info || !info.isReady) {\n            log(`[${this.node.name}] Attempted to use skill [${skillId}] but it's not ready or doesn't exist.`);\n            return false;\n        }\n\n        // const skill = info.skill;\n        // const target = this.targeting?.getCurrentTarget(); // 获取当前目标\n\n        // TODO: 1. 检查技能所需的目标类型是否匹配当前目标\n        // if (!skill.checkTargetType(target)) return false;\n\n        // TODO: 2. 检查施法距离\n        // const targetNode = target?.getNode();\n        // if (!skill.checkRange(this.node.worldPosition, targetNode?.worldPosition)) return false;\n\n        // TODO: 3. 检查资源消耗 (MP, 能量等)\n        // if (!this.stats?.hasEnoughResource(skill.cost)) return false;\n\n        // --- 所有条件满足，开始执行技能 --- \n        log(`[${this.node.name}] Using skill [${skillId}]...`);\n\n        // a. 消耗资源\n        // this.stats.consumeResource(skill.cost);\n\n        // b. 进入冷却\n        info.isReady = false;\n        info.cooldownTimer = 10; // skill.getCooldown(this.stats); // 获取计算冷却缩减后的CD\n\n        // c. 播放施法动画 (如果需要前摇)\n        // this.node.emit('play-animation', skill.castAnimationName, false);\n\n        // d. 执行技能效果 (可能需要延迟以匹配施法动画)\n        // const castTime = skill.getCastTime(this.stats);\n        // if (castTime > 0) {\n        //      // 进入施法状态 (通知 AI 或其他组件)\n        //      this.node.emit('enter-state', CharacterState.CASTING);\n        //      this.scheduleOnce(() => {\n        //          this.executeSkillEffect(skill, target);\n        //          this.node.emit('exit-state', CharacterState.CASTING);\n        //      }, castTime);\n        // } else {\n        //      // 瞬发技能\n        //      this.executeSkillEffect(skill, target);\n        // }\n\n        warn(`Skill execution logic for [${skillId}] not implemented!`);\n        this.scheduleOnce(() => { this.executeSkillEffectPlaceholder(skillId); }, 0.1); // 临时占位\n\n        return true;\n    }\n\n    // 临时的技能效果执行占位符\n    private executeSkillEffectPlaceholder(skillId: string): void {\n        log(`Skill [${skillId}] effect triggered (Placeholder).`);\n        // TODO: 实现真正的技能效果逻辑\n        // - 应用伤害/治疗 (target.applyDamage / target.applyHeal)\n        // - 添加 Buff/Debuff\n        // - 产生特效\n    }\n\n    // --- 公共接口 ---\n    // public getSkillInfo(skillId: string): SkillRuntimeInfo | undefined {\n    //     return this._skills.get(skillId);\n    // }\n}\n\n// --- 辅助类型/接口 (未来可能移到 skills/ 目录下) ---\n\n// interface SkillAsset {\n//     // 定义用于在编辑器中配置技能的数据结构\n//     id: string;\n//     prefab?: Prefab; // 技能特效预制体?\n//     // ... 其他配置数据\n// }\n\n// function createSkillInstance(asset: SkillAsset): SkillBase | null {\n//     // 根据 SkillAsset 创建具体的 SkillBase 实例\n//     // 可能需要一个技能注册表或工厂模式\n//     return null;\n// } "]}