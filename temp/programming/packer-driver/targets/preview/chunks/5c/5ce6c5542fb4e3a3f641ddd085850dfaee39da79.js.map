{"version":3,"sources":["file:///D:/cocos%20creator%20project/TeamBattle/assets/resources/scripts/CameraFollow.ts"],"names":["_decorator","Component","Vec3","Camera","CCFloat","Rect","view","math","BossManager","HealthComponent","PlayerSquadManager","ccclass","property","CameraFollow","type","tooltip","range","slide","camera","initialZ","start","getComponent","console","warn","enabled","playerSquadManager","bossManager","node","position","z","log","lateUpdate","deltaTime","alivePlayerNodes","getAlivePlayerCharacters","currentBoss","bosses","getActiveBosses","length","bossHealth","isValid","isAlive","squadCenterPosition","worldPosition","x","y","totalPos","forEach","add","multiplyScalar","set","targetCameraPos","currentPos","newPos","lerp","positionLerpFactor","localTargetPos","parent","parentWorldMatrix","worldMatrix","invParentWorldMatrix","Mat4","invert","transformMat4","setPosition","calculateBoundingBox","points","minX","maxX","minY","maxY","i","Math","min","max","calculateDesiredOrthoHeight","bounds","paddedWidth","width","padding","paddedHeight","height","screenSize","getVisibleSize","aspectRatio","orthoHeightBasedOnWidth","orthoHeightBasedOnHeight","isNaN","isFinite","minOrthoHeight"],"mappings":"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","sourcesContent":["import { _decorator, Component, Node, Vec3, Camera, CCFloat, Rect, view, math, isValid } from 'cc';\nimport { BossManager } from './BossManager';\nimport { HealthComponent } from './characters/components/HealthComponent';\n// 引入 PlayerSquadManager\nimport { PlayerSquadManager } from './PlayerSquadManager';\n\nconst { ccclass, property } = _decorator;\n\n/**\n * 控制摄像机智能跟随团队和 Boss，并动态调整视野。\n * - 位置聚焦于玩家小队中心。\n * - 视野缩放以包含所有存活玩家和存活 Boss。\n */\n@ccclass('CameraFollow')\nexport class CameraFollow extends Component {\n\n    // 移除 playerCharacterTag\n    // @property({\n    //     type: String,\n    //     tooltip: '标识玩家控制角色的标签'\n    // })\n    // playerCharacterTag: string = \"PlayerCharacter\";\n\n    // 添加 PlayerSquadManager 引用\n    @property({\n        type: PlayerSquadManager,\n        tooltip: '玩家小队管理器实例'\n    })\n    playerSquadManager: PlayerSquadManager | null = null;\n\n    @property({\n        type: BossManager,\n        tooltip: 'Boss管理器实例，用于获取当前 Boss 位置'\n    })\n    bossManager: BossManager | null = null;\n\n    @property({\n        type: CCFloat,\n        tooltip: '摄像机位置跟随的平滑度 (0-1, 值越小越慢)',\n        range: [0, 1, 0.01],\n        slide: true\n    })\n    positionLerpFactor: number = 0.08;\n\n    @property({\n        type: CCFloat,\n        tooltip: '视野边界的额外填充比例 (基于计算出的高度/宽度)',\n        range: [0, 1, 0.05],\n        slide: true\n    })\n    padding: number = 0.2; // 20% 的填充\n\n    @property({\n        type: CCFloat,\n        tooltip: '最小正交高度 (防止缩放过小)'\n    })\n    minOrthoHeight: number = 300;\n\n    @property({\n        type: CCFloat,\n        tooltip: '最大正交高度 (防止缩放过大)'\n    })\n    maxOrthoHeight: number = 1200;\n\n    // 移除 squadFocusWeight，因为现在总是聚焦小队中心\n    // @property({\n    //     type: CCFloat,\n    //     tooltip: '团队中心在焦点计算中的权重 (0-1)',\n    //     range: [0, 1, 0.05],\n    //     slide: true\n    // })\n    // squadFocusWeight: number = 0.6;\n\n    /** @internal */\n    protected camera: Camera | null = null;\n    /** @internal */\n    protected initialZ: number = 0;\n\n    start() {\n        this.camera = this.getComponent(Camera);\n        if (!this.camera) {\n            console.warn('CameraFollow: 节点上缺少 Camera 组件。');\n            this.enabled = false;\n            return;\n        }\n        // 检查 PlayerSquadManager 是否链接\n        if (!this.playerSquadManager) {\n             console.warn('CameraFollow: 未在编辑器中指定 PlayerSquadManager。');\n             // 可能需要禁用或提供默认行为\n             this.enabled = false;\n             return;\n        }\n        if (!this.bossManager) {\n            // BossManager 可能不是必需的，取决于游戏逻辑\n            // warn('CameraFollow: 未指定 BossManager。');\n        }\n\n        this.initialZ = this.node.position.z;\n        console.log(`CameraFollow: Initial Z position recorded: ${this.initialZ}`);\n    }\n\n    lateUpdate(deltaTime: number) {\n        if (!this.camera || !this.enabled || !this.playerSquadManager) {\n            // log(\"CameraFollow: lateUpdate skipped - camera, component disabled, or PlayerSquadManager missing.\");\n            return;\n        }\n\n        // --- 1. 获取存活角色和 Boss --- \n        const alivePlayerNodes = this.playerSquadManager.getAlivePlayerCharacters();\n\n        let currentBoss: Node | null = null;\n        if (this.bossManager) {\n             const bosses = this.bossManager.getActiveBosses(); // 假设 BossManager 已经过滤了无效/死亡 Boss\n             if (bosses && bosses.length > 0) {\n                  currentBoss = bosses[0]; // 简化处理，只考虑第一个 Boss\n                  const bossHealth = currentBoss?.getComponent(HealthComponent);\n                  if (!currentBoss || !currentBoss.isValid || !bossHealth || !bossHealth.isAlive()) {\n                       currentBoss = null; // 无效或死亡的 Boss\n                  }\n             }\n        }\n\n        // 如果没有任何存活单位，不进行操作\n        if (alivePlayerNodes.length === 0 && !currentBoss) {\n            return;\n        }\n\n        // --- 2. 计算小队中心点 (用于摄像机定位) --- \n        let squadCenterPosition = new Vec3(this.node.worldPosition.x, this.node.worldPosition.y, 0); // Fallback to current camera XY\n        if (alivePlayerNodes.length > 0) {\n            const totalPos = new Vec3();\n            alivePlayerNodes.forEach(node => {\n                totalPos.add(node.worldPosition);\n            });\n            squadCenterPosition = totalPos.multiplyScalar(1 / alivePlayerNodes.length);\n        } else if (currentBoss) {\n             squadCenterPosition.set(currentBoss.worldPosition);\n        }\n\n        // --- 3. 准备计算边界的点集 (用于视野缩放) --- \n        // this.pointsForBounds.length = 0;\n        // alivePlayerNodes.forEach(node => this.pointsForBounds.push(node.worldPosition));\n        // if (currentBoss) {\n        //     this.pointsForBounds.push(currentBoss.worldPosition);\n        // }\n        //\n        // // 如果 pointsForBounds 为空 (理论上不会到这里，因为前面有检查)，则添加小队中心点作为参考\n        // if (this.pointsForBounds.length === 0) {\n        //      this.pointsForBounds.push(squadCenterPosition.clone());\n        // }\n        //\n        // // --- 4. 计算边界和视野 --- \n        // const bounds = this.calculateBoundingBox(this.pointsForBounds);\n        // let desiredOrthoHeight = this.calculateDesiredOrthoHeight(bounds);\n        // desiredOrthoHeight = math.clamp(desiredOrthoHeight, this.minOrthoHeight, this.maxOrthoHeight);\n        // log(`[${this.node.name}] lateUpdate: Bounds Center: (${bounds.center.x.toFixed(1)}, ${bounds.center.y.toFixed(1)}), Desired OrthoHeight: ${desiredOrthoHeight.toFixed(1)}`);\n \n        // --- 5. 应用平滑移动 --- \n        // 位置: 移动到小队中心点\n        const targetCameraPos = new Vec3(squadCenterPosition.x, squadCenterPosition.y, this.initialZ);\n\n        const currentPos = this.node.position;\n        const newPos = new Vec3();\n        Vec3.lerp(newPos, currentPos, targetCameraPos, this.positionLerpFactor); // 这里的 targetCameraPos 是世界坐标，而 node.position 是父节点下的局部坐标，需要转换\n\n        // --- 修正：将世界坐标目标转换为摄像机节点的局部坐标 --- \n        let localTargetPos = new Vec3();\n        if (this.node.parent) { // 确保摄像机有父节点 (通常是 Scene)\n            const parentWorldMatrix = this.node.parent.worldMatrix;\n            const invParentWorldMatrix = new math.Mat4();\n            math.Mat4.invert(invParentWorldMatrix, parentWorldMatrix);\n            Vec3.transformMat4(localTargetPos, targetCameraPos, invParentWorldMatrix);\n        } else {\n             localTargetPos = targetCameraPos;\n        }\n\n        // 使用转换后的局部坐标进行 lerp\n        Vec3.lerp(newPos, this.node.position, localTargetPos, this.positionLerpFactor);\n        // --- 修正结束 ---\n\n        this.node.setPosition(newPos);\n\n        // --- 视野缩放逻辑已禁用 ---\n        // const currentOrthoHeight = this.camera.orthoHeight;\n        // const newOrthoHeight = math.lerp(currentOrthoHeight, desiredOrthoHeight, this.zoomLerpFactor);\n        // this.camera.orthoHeight = newOrthoHeight;\n    }\n\n    // 移除 findAndAddPlayersRecursive\n    // private findAndAddPlayersRecursive(parentNode: Node, playerTag: string): void { ... }\n\n    /**\n     * 计算包含所有给定点的最小边界框 (世界坐标)\n     * @param points Vec3 世界坐标点数组\n     * @returns Rect 边界框\n     */\n    private calculateBoundingBox(points: Vec3[]): Rect {\n        if (!points || points.length === 0) {\n            // 如果没有点，返回一个以摄像机当前位置为中心的小矩形\n            const currentPos = this.node.worldPosition;\n            return new Rect(currentPos.x - 1, currentPos.y - 1, 2, 2);\n        }\n\n        let minX = points[0].x;\n        let maxX = points[0].x;\n        let minY = points[0].y;\n        let maxY = points[0].y;\n\n        for (let i = 1; i < points.length; i++) {\n            minX = Math.min(minX, points[i].x);\n            maxX = Math.max(maxX, points[i].x);\n            minY = Math.min(minY, points[i].y);\n            maxY = Math.max(maxY, points[i].y);\n        }\n\n        return new Rect(minX, minY, maxX - minX, maxY - minY);\n    }\n\n    /**\n     * 根据目标边界框计算理想的正交高度\n     * @param bounds 包含所有目标的边界框 (世界坐标)\n     * @returns 理想的 orthoHeight\n     */\n    private calculateDesiredOrthoHeight(bounds: Rect): number {\n        // 考虑填充\n        const paddedWidth = bounds.width * (1 + this.padding);\n        const paddedHeight = bounds.height * (1 + this.padding);\n\n        // 获取屏幕宽高比\n        const screenSize = view.getVisibleSize();\n        const aspectRatio = screenSize.width / screenSize.height;\n\n        // 计算所需的 orthoHeight\n        const orthoHeightBasedOnWidth = (paddedWidth / aspectRatio) / 2;\n        const orthoHeightBasedOnHeight = paddedHeight / 2;\n\n        // 取两者中较大的值，确保都能容纳\n        // 同时确保 orthoHeight 不会是 NaN 或 Infinity (例如当 bounds.width/height 为 0 时)\n        let height = Math.max(orthoHeightBasedOnWidth, orthoHeightBasedOnHeight);\n        if (isNaN(height) || !isFinite(height)) {\n            height = this.minOrthoHeight; // Fallback to min height\n        }\n        return Math.max(this.minOrthoHeight, height); // 确保至少是最小高度\n    }\n}"]}