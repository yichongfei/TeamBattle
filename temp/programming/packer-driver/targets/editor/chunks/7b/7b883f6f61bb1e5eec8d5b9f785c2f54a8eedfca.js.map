{"version":3,"sources":["file:///D:/cocos%20creator%20project/TeamBattle/assets/resources/scripts/characters/components/TargetingComponent.ts"],"names":["_decorator","Component","Vec3","RoleComponent","HealthComponent","RoleType","BossManager","ccclass","property","TargetingComponent","type","tooltip","Number","aggroRadius","_currentTarget","_searchTimer","SEARCH_INTERVAL","start","role","console","warn","node","name","enabled","bossManagerComponent","log","update","deltaTime","findBestTarget","isTargetValid","clearTarget","bestTarget","MELEE_DPS","RANGED_DPS","TANK","findNearestEnemy","HEALER","findLowestHealthAlly","setTarget","bosses","getActiveBosses","e","length","nearestEnemy","minDistanceSq","Infinity","bossNode","isValid","healthComp","getComponent","isAlive","targetable","distanceSq","squaredDistance","worldPosition","getPosition","target","oldTarget","getNode","emit","getCurrentTarget"],"mappings":"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","sourcesContent":["import { _decorator, Component, Node, Vec3 } from 'cc';\nimport { RoleComponent } from './RoleComponent'; // 需要根据角色定位选择目标\nimport { HealthComponent } from './HealthComponent'; // 需要判断目标或友方是否存活/低血量\nimport { ITargetable } from '../../common/Interfaces';\nimport { RoleType } from '../../common/Enums';\nimport { BossManager } from '../../BossManager'; // User confirmed this import works\n\nconst { ccclass, property } = _decorator;\n\n/**\n * 负责为角色选择合适的目标 (敌人或友方)。\n * 其逻辑会根据角色定位 (RoleComponent) 和战场信息变化。\n */\n@ccclass('TargetingComponent')\nexport class TargetingComponent extends Component {\n\n    @property(RoleComponent)\n    private role: RoleComponent = null;\n\n    // --- 使用用户添加的 BossManager 节点引用 ---\n    @property({\n        type: BossManager,\n        tooltip: '全局 Boss 管理器节点，用于获取敌方 Boss 列表'\n    })\n    bossManagerComponent: BossManager | null = null;\n    // --\n\n    // --- 索敌参数 ----\n    aggroRadius: number = 0 ;\n\n    @property({\n        type: Number,\n        tooltip: '搜索友方 (治疗目标) 的最大范围，0 表示无限'\n    })\n    healRadius: number = 1000;\n\n    // --- 内部状态 ---\n    private _currentTarget: ITargetable | null = null; // 当前选定的目标\n    private _searchTimer: number = 0;\n    private readonly SEARCH_INTERVAL: number = 0.5; // 每隔多少秒重新索敌一次\n\n    start() {\n        if (!this.role) {\n            console.warn(`[${this.node.name}] 的 TargetingComponent 需要一个 RoleComponent。`);\n            this.enabled = false;\n            return;\n        }\n        if (!this.bossManagerComponent) {\n            console.warn(`[${this.node.name}] 的 TargetingComponent 需要在编辑器中链接 'Boss Manager Component' 属性。`);\n        } else {\n            console.log(`[${this.node.name}] TargetingComponent 已链接 BossManager。`);\n        }\n    }\n\n    update(deltaTime: number) {\n        this._searchTimer += deltaTime;\n        if (this._searchTimer >= this.SEARCH_INTERVAL) {\n            this._searchTimer = 0;\n            this.findBestTarget();\n        }\n\n        if (this._currentTarget && !this.isTargetValid(this._currentTarget)) {\n            console.log(`[${this.node.name}] 当前目标不再有效。`);\n            this.clearTarget();\n            this.findBestTarget(); // 立刻尝试寻找新目标\n        }\n    }\n\n    // --- 核心索敌逻辑 ---\n    private findBestTarget(): void {\n        let bestTarget: ITargetable | null = null;\n\n        switch (this.role.role) {\n            case RoleType.MELEE_DPS:\n            case RoleType.RANGED_DPS:\n            case RoleType.TANK:\n                bestTarget = this.findNearestEnemy();\n                // TODO: TANK 可能需要考虑仇恨最高的敌人\n                break;\n            case RoleType.HEALER:\n                bestTarget = this.findLowestHealthAlly();\n                break;\n            // ... 其他角色类型\n        }\n\n        if (bestTarget && bestTarget !== this._currentTarget) {\n            this.setTarget(bestTarget);\n        } else if (!bestTarget && this._currentTarget) {\n            // 如果找不到新目标，但之前有目标，则清除\n            // 但也许不清除更好？让角色停留在原地？取决于设计\n            // this.clearTarget();\n        }\n    }\n\n    private findNearestEnemy(): ITargetable | null {\n        if (!this.bossManagerComponent) {\n            console.warn(`[${this.node.name}] TargetingComponent: BossManagerComponent not linked or invalid.`);\n            return null;\n        }\n\n        let bosses: Node[] = [];\n        try {\n            bosses = this.bossManagerComponent.getActiveBosses();\n        } catch (e) {\n            console.warn(`[${this.node.name}] TargetingComponent: Error calling getActiveBosses():`, e);\n            return null;\n        }\n\n        if (!bosses || bosses.length === 0) {\n            return null; // 没有 Boss 可以作为目标\n        }\n\n        let nearestEnemy: ITargetable | null = null;\n        let minDistanceSq = this.aggroRadius > 0 ? this.aggroRadius * this.aggroRadius : Infinity;\n\n        for (const bossNode of bosses) {\n            if (!bossNode || !bossNode.isValid) {\n                continue;\n            }\n\n            const healthComp = bossNode.getComponent(HealthComponent);\n            if (!healthComp) {\n                continue;\n            }\n            if (!healthComp.isAlive()) {\n                continue;\n            }\n\n            // 确保目标实现了 ITargetable (HealthComponent 应该实现它)\n            // 在 TypeScript 中，接口不能直接检查，但我们可以假定 HealthComponent 符合要求\n            // 如果需要更严格，可以添加一个标记属性或方法到 ITargetable\n            const targetable = healthComp as ITargetable; \n\n            const distanceSq = Vec3.squaredDistance(this.node.worldPosition, targetable.getPosition());\n\n            if (distanceSq < minDistanceSq) {\n                minDistanceSq = distanceSq;\n                nearestEnemy = targetable;\n            }\n            else {\n            }\n        }\n\n        if (!nearestEnemy) {\n           \n        }\n        return nearestEnemy;\n    }\n\n    // (Placeholder for faction check - needs implementation)\n    // private isEnemyFaction(targetNode: Node): boolean {\n    //     // Simple check: assumes anything not self is enemy for now\n    //     return targetNode !== this.node;\n    // }\n\n    private findLowestHealthAlly(): ITargetable | null {\n        console.warn(`[${this.node.name}] TargetingComponent: findLowestHealthAlly() not implemented!`);\n        return null;\n    }\n\n    // --- 目标管理 ---\n    private setTarget(target: ITargetable): void {\n        if (this._currentTarget === target) return;\n        const oldTarget = this._currentTarget;\n        this._currentTarget = target;\n        console.log(`[${this.node.name}] TargetingComponent: Acquired new target: [${target.getNode()?.name ?? 'Unknown'}]`);\n        this.node.emit('target-changed', this._currentTarget, oldTarget);\n    }\n\n    /**\n     * 清除当前目标。\n     * 由 AIComponent 在发现目标无效时调用，或 TargetingComponent 内部调用。\n     */\n    public clearTarget(): void {\n        if (!this._currentTarget) return;\n        console.log(`[${this.node.name}] TargetingComponent: Target cleared.`);\n        const oldTarget = this._currentTarget;\n        this._currentTarget = null;\n        this.node.emit('target-changed', null, oldTarget);\n    }\n\n    private isTargetValid(target: ITargetable | null): boolean {\n        if (!target || !target.getNode() || !target.getNode().isValid) {\n            return false;\n        }\n        // 检查目标是否存活\n        const healthComp = target.getNode().getComponent(HealthComponent);\n        if (!healthComp || !healthComp.isAlive()) {\n            return false;\n        }\n\n        // 可以添加其他检查，例如距离、是否在视野内等\n        // const distance = Vec3.distance(this.node.worldPosition, target.getPosition());\n        // if (this.role.role === RoleType.HEALER && distance > this.healRadius) return false;\n        // if (this.role.role !== RoleType.HEALER && distance > this.aggroRadius * 1.2) return false; // 加个缓冲，防止目标在边缘反复丢失\n\n        return true;\n    }\n\n    // --- 公共接口 ---\n    public getCurrentTarget(): ITargetable | null {\n        // 返回前再次校验有效性\n        if (!this.isTargetValid(this._currentTarget)) {\n            this._currentTarget = null; // 内部清除无效目标\n        }\n        return this._currentTarget;\n    }\n}\n\n// Helper function (需要实现或放到 GameManager/Service Locator)\n// function findManager<T extends Component>(type: new () => T): T | null {\n//     // 实现查找逻辑，例如通过场景查找特定节点或使用单例\n//     return null;\n// } "]}